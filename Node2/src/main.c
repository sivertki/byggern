#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>

#include "SPIDriver2.h"
#include "MCPDriver2.h"
#include "CANDriver.h"
#include "UARTDriver2.h"
#include "ServoDriver.h"
#include "avr/interrupt.h"
#include "IRDriver.h"
#include "MotorDriver.h"
#include "Controller.h"
#include "MCP2515.h"
#include "SolenoidDriver.h"

void joy_cal();

short int scaleJoystickSpeed(uint8_t joystickIn);

/**
 * \brief An int containing the center of the joystick X-axis.
 * This value will be updated each time the node restarts as the center can
 * drift around.
 */
static int xCenter = 0;

/**
 * \brief An int containing the center of the joystick Y-axis.
 * This value will be updated each time the node restarts as the center can
 * drift around.
 */
static int yCenter = 0;

/**
 * \brief
 */
static uint8_t gameScore = 0;

/**
 * \brief
 */
Control control_type = JOYSTICK;

/**
 * \brief
 */
typedef enum IsCounting {yesCounting, noCounting} IsCounting;

/**
 * \brief
 */
IsCounting counting_state = noCounting;

int result = 0;


int main (void) {
  cli();
  // Set pin49 as output
  DDRL |= (1<<PL0);
  USART_Init();
  SPI_init();
  can_init();
  SERVO_init();
  IR_init();
  MOTOR_initialize();
  CONTROLLER_Init();
  SOLENOID_init();
  //MCP_init();
  //joy_cal();

  //PD controller values
  //CONTROLLER_setControlTerms(0.25,0.00,0.35);


  xCenter = 130;
  yCenter = 130;

  //TODO tune dis sjiiiit

  //0.2,0.005,0.1
  //K_p = getTerm(1);
  //K_i = getTerm(2);
  //K_d = getTerm(3);
  //printf("K_p: %i, K_i: %i, K_d: %i\n\r", K_p, K_i, K_d);
  printf("Node 2 initialized!\n\r");
  _delay_ms(1000);

  //sei();
  control_type = INITIALIZE;
  sei();


  //TODO maybe move all this into its own function in controller.c??
  short int ref = scaleJoystickSpeed(255);
  printf("Ref: %hi\n\r", ref);
  CONTROLLER_setReference(ref);
  _delay_ms(2500);
  MOTOR_resetEncoder();
  CONTROLLER_setEncoderSum(0);
  ref = scaleJoystickSpeed(0);
  printf("Ref: %hi\n\r", ref);
  CONTROLLER_setReference(ref);
  _delay_ms(2500);
  printf("Encoder Sum: %hi\n\r", CONTROLLER_getEncoderSum());
  CONTROLLER_setEncoderMax(CONTROLLER_getEncoderSum());

  control_type = NONE;
  MCP_init();
  //printf("MCP initialized\n\r");
  //joy_cal();

  //TODO fix with received message
  //CONTROLLER_setControlTerms(2,0.005,0.2);
  //2,0.064,6.25
  //control_type = PID;
  printf("Entering while loop!\n\r");

  while(1) {

    //set high
    /*
    PORTL |= (1<<PL0);
    _delay_ms(1000);
    //set low
    PORTL &= ~(1<<PL0);
    _delay_ms(1000);
    */

    result += IR_detect_goal();

    if(result == 1) {
      printf("Result==1 \n\r");
      struct CANMessage lossMessage;
      lossMessage.id = 3;
      lossMessage.length = 1;
      lossMessage.data[0] = gameScore;
      counting_state = noCounting;
      can_message_send(&lossMessage);
      result++;
      gameScore = 0;
    }

    _delay_ms(500);
    //printf("Error: %hi, Output: %hi, encoder sum: %hi, current state: %d\n\r", getError(), getOutput(), CONTROLLER_getEncoderSum(), control_type);
  }
}

void joy_cal() {
     struct CANMessage receivedMessage;
     receivedMessage = can_data_receive(BufferZero);

     yCenter = receivedMessage.data[0];
     xCenter = receivedMessage.data[1];

     printf("Calibration complete. Center Y = %d & Center X = %d\n\r", yCenter, xCenter);

     //_delay_ms(500);
 }

short int scaleJoystickSpeed(uint8_t joystickIn) {
   if(joystickIn < xCenter *0.8) {
     float motorSpeed = 255 - 2*joystickIn;
     return (short int) (- motorSpeed);
   }
   else if(joystickIn > xCenter *1.2) {
     float motorSpeed = 40 + 2.5*(joystickIn-170);
     return  (short int) motorSpeed;
   }
   else {
     return 0;
   }
 }

 short int scaleSliderSpeed(uint8_t sliderIn) {
   float scaleConstant = CONTROLLER_getEncoderMax()/255;
   return (short int) sliderIn*scaleConstant;
 }

/**
 * \brief The interrupt generated by recieving a CAN message.
 * This interrupt will trigger when recieving a CAN message from the other nodes
 * and will make Node 2 read the appropriate registers containing the CAN message.
 */
ISR(INT4_vect) {

  // A CANMessage that is used for storing the last recieved CAN message.

  struct CANMessage receivedMessage;

  uint8_t joystickVal;
  uint8_t leftsliderVal;
  short int new_reference;
  uint8_t servoVal;

  uint8_t int_flags = MCP_reads(MCP_CANINTF);

  //clear interrupt flags in CAN controller
  MCP_writes(MCP_CANINTF, 0x00);

  uint8_t bufferZero = int_flags & 0b01;
  uint8_t bufferOne = int_flags & 0b10;

  if(control_type == INITIALIZE) {
    return;
  }

  //short int scaledJoystickValue;

  //control_type = PID;

  if(bufferOne) {
      receivedMessage = can_data_receive(BufferOne);

  } else if(bufferZero) {
      receivedMessage = can_data_receive(BufferZero);
  }


  switch (receivedMessage.id) {
    case 0: //All ADC values in Slider mode

      // Position-control
      leftsliderVal = 255 - receivedMessage.data[0];
      new_reference = scaleSliderSpeed(leftsliderVal);
      CONTROLLER_setReference(new_reference);
      //printf("Encoder sum: %hi, Reference value: %hi\n\r", CONTROLLER_getEncoderSum(), new_reference);

      // Servo-control
      servoVal = receivedMessage.data[1];
      SERVO_setDutyCycle(255 - servoVal); //To invert direction

      break;
    case 1: //All ADC values in Joystick mode

      // Speed-control
      joystickVal = receivedMessage.data[3];
      new_reference = scaleJoystickSpeed(joystickVal);
      CONTROLLER_setReference(new_reference);

      // Servo-control
      servoVal = receivedMessage.data[1];
      SERVO_setDutyCycle(255 - servoVal); //To invert direction
      //printf("Error: %hi, ErrorSum: %hi\n\r", getError(), getErrorSum());
      break;
    case 2: //Button message, contains all buttons
      //check if joystick button is pressed
      if(receivedMessage.data[0] & 0b1) {
        SOLENOID_fire();
      }
      break;
    case 3:
      break;
    case 4:
      printf("MESSAGE 4 INTERRUPT!!!\n\r");
      gameScore = 0;
      result = 0;
      counting_state = yesCounting;

      if(!receivedMessage.data[0]) {
        CONTROLLER_setControlTerms(0.25,0.00,0.35);
        control_type = JOYSTICK;
      }
      else if(receivedMessage.data[0]) {
        CONTROLLER_setControlTerms(2,0.005,0.2);
        control_type = SLIDER;
      }
      break;

  }
    //printf("Received data: %u\r\n", receivedMessage.data[0]);

    //printf(" Scaled value: %hu\n\r", getScaledSensorValue(receivedMessage.data[0]));
    //SERVO_SetDutyCycle(receivedMessage.data[0]);
    //MOTOR_setMovement(receivedMessage.data[1]);



  //clear interrupt flag
  EIFR &= ~(1<<4);
}

int scoreIterator = 0;

/**
 * \brief This interrupt is generated by a timer.
 * This interrupt is responsible for updating the controller, which entails calculation
 * of the next controller output and clearing the encoder.
 */
ISR(TIMER3_OVF_vect) {
  if(control_type != NONE) {
    CONTROLLER_updateController(control_type);
  }

  if(counting_state == yesCounting) {
    scoreIterator++;

    if(scoreIterator == 100) {
      gameScore++;
      scoreIterator = 0;
      printf("gameScore %u\n\r", gameScore);
    }
  }
 }

/**
 * \brief This interrupt is triggered when no other interrupt can be reached.
 * This interrupt will be triggered when there is an error with interrupts and
 * the correct interrupt does not exist or cannot be reached.
 */
ISR(BADISR_vect){
  printf("BAD INTERRUPT!\n\r");
}
